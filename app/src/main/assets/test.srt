1
00:00:00,500 --> 00:00:09,779
[APPLAUSE]

2
00:00:09,779 --> 00:00:10,570
COLT MCANLIS: Yeah!

3
00:00:13,972 --> 00:00:18,380
Google I/O, 2016, right?

4
00:00:18,380 --> 00:00:19,081
Oh, come on.

5
00:00:19,081 --> 00:00:20,080
We're done clapping now?

6
00:00:20,080 --> 00:00:20,933
Is that it?

7
00:00:20,933 --> 00:00:21,900
[LAUGHTER]

8
00:00:21,900 --> 00:00:22,890
All right, we're done.

9
00:00:22,890 --> 00:00:23,700
Hello, everyone.

10
00:00:23,700 --> 00:00:24,700
How are you doing today?

11
00:00:24,700 --> 00:00:25,570
Good?

12
00:00:25,570 --> 00:00:27,720
Staying out of the sun?

13
00:00:27,720 --> 00:00:28,220
Yes?

14
00:00:28,220 --> 00:00:29,140
Fantastic.

15
00:00:29,140 --> 00:00:31,137
Hey, I want to thank everybody for being here.

16
00:00:31,137 --> 00:00:33,220
My name is Colt McAnlis, and I've got to tell you,

17
00:00:33,220 --> 00:00:37,050
I love Google I/O. I love Google I/O, because this is the one

18
00:00:37,050 --> 00:00:40,240
time during the whole year that the crazy Googlers get

19
00:00:40,240 --> 00:00:42,600
to talk to all of you all about the weird stuff we

20
00:00:42,600 --> 00:00:44,641
do that we can't talk about the rest of the year.

21
00:00:44,641 --> 00:00:46,164
And that is fantastic, right?

22
00:00:46,164 --> 00:00:47,830
And today, we're talking about something

23
00:00:47,830 --> 00:00:51,300
that's so near and dear to my heart, and that's data compression.

24
00:00:51,300 --> 00:00:54,540
It is, by far, one of my favorite, most obsessive things

25
00:00:54,540 --> 00:00:56,020
that I ever get involved with.

26
00:00:56,020 --> 00:00:57,790
And I'm so happy that all of you are here.

27
00:00:57,790 --> 00:00:59,790
And all the people standing outside-- I'm sorry.

28
00:00:59,790 --> 00:01:01,400
There's capacity issues.

29
00:01:01,400 --> 00:01:03,660
We'll give them a t-shirt or something later.

30
00:01:03,660 --> 00:01:06,940
But really quick, before we begin, I've got to tell you,

31
00:01:06,940 --> 00:01:08,580
we've only got 45 minutes today.

32
00:01:08,580 --> 00:01:11,860
And that is just not enough time to get

33
00:01:11,860 --> 00:01:15,740
through all the awesome, crazy image compression content

34
00:01:15,740 --> 00:01:17,020
that we need to get done.

35
00:01:17,020 --> 00:01:18,070
So over the past couple of weeks,

36
00:01:18,070 --> 00:01:20,510
I've been trying to diffuse some of this stuff to some other places.

37
00:01:20,510 --> 00:01:22,440
First off, here's my Medium.com page.

38
00:01:22,440 --> 00:01:24,654
Has anyone been reading these articles?

39
00:01:24,654 --> 00:01:25,579
AUDIENCE: [INAUDIBLE]!

40
00:01:25,579 --> 00:01:26,370
COLT MCANLIS: Yeah!

41
00:01:26,370 --> 00:01:29,195
A round of applause if you've been reading the Medium articles, yeah?

42
00:01:29,195 --> 00:01:30,560
[APPLAUSE]

43
00:01:30,560 --> 00:01:33,120
We're live, folks. you've got to make 'em hear it.

44
00:01:33,120 --> 00:01:34,507
Yeah?

45
00:01:34,507 --> 00:01:36,840
If you read these articles, we get into a lot more depth

46
00:01:36,840 --> 00:01:38,440
on how some of these image formats work

47
00:01:38,440 --> 00:01:39,890
and how to make them a lot smaller.

48
00:01:39,890 --> 00:01:42,769
Second off, of course, is the Android Performance Patterns videos.

49
00:01:42,769 --> 00:01:43,607
Anybody watch these?

50
00:01:43,607 --> 00:01:44,830
[APPLAUSE]

51
00:01:44,830 --> 00:01:45,900
Thank you.

52
00:01:45,900 --> 00:01:47,050
Thank you.

53
00:01:47,050 --> 00:01:48,250
Thank you.

54
00:01:48,250 --> 00:01:49,010
That's fantastic.

55
00:01:49,010 --> 00:01:51,785
Now, if you've ever been interested in data compression,

56
00:01:51,785 --> 00:01:53,410
if you've ever tried to make an attempt

57
00:01:53,410 --> 00:01:55,230
to understand the algorithms, but found

58
00:01:55,230 --> 00:01:57,260
that the math is really weird, or it's

59
00:01:57,260 --> 00:02:00,320
too gnarly of a concept, or maybe it's not presented in the right way,

60
00:02:00,320 --> 00:02:02,570
then good news for you, because Alex Hackey

61
00:02:02,570 --> 00:02:04,090
and I have actually got together,

62
00:02:04,090 --> 00:02:06,276
and we've actually written a data compression book.

63
00:02:06,276 --> 00:02:07,900
And we took a different approach to it.

64
00:02:07,900 --> 00:02:10,250
We threw out all the math.

65
00:02:10,250 --> 00:02:13,300
All of that crazy gnarly stuff that makes your brain melt,

66
00:02:13,300 --> 00:02:14,074
we got rid of it.

67
00:02:14,074 --> 00:02:15,490
And we re-approached how we should

68
00:02:15,490 --> 00:02:20,120
be teaching data compression to modern developers and engineers.

69
00:02:20,120 --> 00:02:23,080
So if you're interested in a deep, fundamental understanding

70
00:02:23,080 --> 00:02:26,671
of how to make your apps smaller for users, check out this book.

71
00:02:26,671 --> 00:02:27,170
Deal?

72
00:02:27,170 --> 00:02:27,787
Deal?

73
00:02:27,787 --> 00:02:29,370
All right, business is out of the way.

74
00:02:29,370 --> 00:02:30,130
Let's get started.

75
00:02:30,130 --> 00:02:32,560
So when we talk about reducing the data

76
00:02:32,560 --> 00:02:35,310
sizes of your applications for your users,

77
00:02:35,310 --> 00:02:38,090
there's generally two buckets that I like to think of.

78
00:02:38,090 --> 00:02:40,364
On one side, is your APK size.

79
00:02:40,364 --> 00:02:41,780
And this includes all of the stuff

80
00:02:41,780 --> 00:02:45,480
like code sizes, language information resources, image resources.

81
00:02:45,480 --> 00:02:47,460
We've got layout data, config, blah, blah,

82
00:02:47,460 --> 00:02:49,790
blah-- all of the information that's

83
00:02:49,790 --> 00:02:53,250
zipped up into a single APK file and downloaded when

84
00:02:53,250 --> 00:02:55,090
users install your application.

85
00:02:55,090 --> 00:02:58,520
Now, on the other side of things is all of the other stuff

86
00:02:58,520 --> 00:03:01,780
that your app downloads once it's installed from the internet, right?

87
00:03:01,780 --> 00:03:03,970
So this could be many, many, many things,

88
00:03:03,970 --> 00:03:07,090
but it mostly boils down to images and serialized data.

89
00:03:07,090 --> 00:03:09,720
Now, I've got to say that the APK stuff, making

90
00:03:09,720 --> 00:03:13,425
your APKs smaller, is a whole deep and crazy domain

91
00:03:13,425 --> 00:03:15,050
that we're not going to get into today.

92
00:03:15,050 --> 00:03:16,880
However, if you stay in your seats,

93
00:03:16,880 --> 00:03:21,100
the next session will go very, very deep into that subject.

94
00:03:21,100 --> 00:03:23,520
So make sure you stick around for that.

95
00:03:23,520 --> 00:03:25,070
One thing you notice here, though,

96
00:03:25,070 --> 00:03:28,547
is that images actually show up in both of these categories.

97
00:03:28,547 --> 00:03:30,630
And that's why we're focusing on our images today.

98
00:03:30,630 --> 00:03:33,107
Because quite frankly, images are awesome, right?

99
00:03:33,107 --> 00:03:34,315
Round of applause for images?

100
00:03:34,315 --> 00:03:35,120
[APPLAUSE]

101
00:03:35,120 --> 00:03:35,620
Yeah?

102
00:03:39,110 --> 00:03:42,290
I promise you, I will ask you to applaud weirder and weirder

103
00:03:42,290 --> 00:03:46,510
stuff as the talk goes on, like who likes gummy bears?

104
00:03:46,510 --> 00:03:47,770
[APPLAUSE]

105
00:03:47,770 --> 00:03:48,694
Yeah, there we go.

106
00:03:48,694 --> 00:03:51,360
We have to have an understanding as an audience and a presenter.

107
00:03:51,360 --> 00:03:53,090
That's how this works, right?

108
00:03:53,090 --> 00:03:54,500
Images are fantastic.

109
00:03:54,500 --> 00:03:55,920
We use them in our applications.

110
00:03:55,920 --> 00:03:59,000
We convey emotion, and power, and information,

111
00:03:59,000 --> 00:04:00,430
and all this other great stuff.

112
00:04:00,430 --> 00:04:04,040
But images also have a problem, is that they're easy to bloat.

113
00:04:04,040 --> 00:04:05,900
They're easy to get too big, and too many

114
00:04:05,900 --> 00:04:07,590
resolutions, and too many pixels.

115
00:04:07,590 --> 00:04:10,040
And that causes problems for your users,

116
00:04:10,040 --> 00:04:11,900
because bigger images take longer

117
00:04:11,900 --> 00:04:13,970
to download, which means that there's

118
00:04:13,970 --> 00:04:17,310
more bits on the wire, which costs your users more money

119
00:04:17,310 --> 00:04:19,700
to download them, because they're on metered plans.

120
00:04:19,700 --> 00:04:21,754
And their cellular radio is on longer,

121
00:04:21,754 --> 00:04:25,400
downloading the larger images, so you're eating their battery more.

122
00:04:25,400 --> 00:04:27,290
All of these little things add up

123
00:04:27,290 --> 00:04:29,430
when you start bringing these images down,

124
00:04:29,430 --> 00:04:32,480
which is why making sure that your images are compressed

125
00:04:32,480 --> 00:04:36,460
as good and as small as possible is super important to make sure

126
00:04:36,460 --> 00:04:39,600
that your users are having the best experience.

127
00:04:39,600 --> 00:04:41,650
And in general, there's a lot of different things

128
00:04:41,650 --> 00:04:42,691
you could do with images.

129
00:04:42,691 --> 00:04:45,900
But as Android developers, there's really only four data

130
00:04:45,900 --> 00:04:50,640
formats we care about-- PNGs, VectorDrawables, JPEGs and WebP.

131
00:04:50,640 --> 00:04:53,210
Now, the rest of the talk that we're going to go into today

132
00:04:53,210 --> 00:04:55,900
is going to be opening up each one of these formats,

133
00:04:55,900 --> 00:04:58,020
taking a look at how it works internally

134
00:04:58,020 --> 00:05:01,250
and how you can squeeze out every bit of data

135
00:05:01,250 --> 00:05:02,750
from these things possible.

136
00:05:02,750 --> 00:05:05,250
Sound good?

137
00:05:05,250 --> 00:05:05,980
Sound good?

138
00:05:05,980 --> 00:05:07,390
[APPLAUSE]

139
00:05:07,390 --> 00:05:08,282
Yes.

140
00:05:08,282 --> 00:05:10,740
Don't worry, you'll will get the hang of the applause cues.

141
00:05:10,740 --> 00:05:12,800
They took down the sign that I asked for later.

142
00:05:12,800 --> 00:05:13,301
That's OK.

143
00:05:13,301 --> 00:05:13,800
All right.

144
00:05:13,800 --> 00:05:15,530
So let's start at the top with PNG files.

145
00:05:15,530 --> 00:05:19,632
PNGs have to be one of the most amazing formats in terms

146
00:05:19,632 --> 00:05:20,590
of Android development.

147
00:05:20,590 --> 00:05:22,880
They've been here as long as anybody has seen.

148
00:05:22,880 --> 00:05:26,770
They provide amazing quality and, actually, pretty good

149
00:05:26,770 --> 00:05:27,930
data compression.

150
00:05:27,930 --> 00:05:30,190
So let's figure out what's going on under the hood.

151
00:05:30,190 --> 00:05:31,610
So let's say we have an image.

152
00:05:31,610 --> 00:05:34,050
The way PNG compression works is that we

153
00:05:34,050 --> 00:05:38,270
take every row of pixels in that image, one at a time,

154
00:05:38,270 --> 00:05:40,130
we process each row individually.

155
00:05:40,130 --> 00:05:43,230
And what we do is, we apply something called a filter to it.

156
00:05:43,230 --> 00:05:47,480
Now, the filter itself is basically a modified delta processor, right?

157
00:05:47,480 --> 00:05:50,100
So basically, it's going to try to subtract the current pixel

158
00:05:50,100 --> 00:05:52,350
in the row from the previous pixels, or the one above it,

159
00:05:52,350 --> 00:05:53,474
and do all this weird math.

160
00:05:53,474 --> 00:05:56,370
The point of the filter is simple.

161
00:05:56,370 --> 00:05:58,980
It wants to produce the most number of zeros

162
00:05:58,980 --> 00:06:00,540
and duplicate values possible.

163
00:06:00,540 --> 00:06:01,330
That's it.

164
00:06:01,330 --> 00:06:03,040
That's all it wants to do.

165
00:06:03,040 --> 00:06:06,640
The output of that is then fed into a very common,

166
00:06:06,640 --> 00:06:09,973
super-everywhere encoding system called, deflate.

167
00:06:09,973 --> 00:06:11,223
Anybody familiar with deflate?

168
00:06:11,223 --> 00:06:13,490
[ONE PERSON APPLAUDS]

169
00:06:13,490 --> 00:06:15,412
Get him a t-shirt.

170
00:06:15,412 --> 00:06:16,202
[LAUGHTER]

171
00:06:16,202 --> 00:06:16,910
That's all right.

172
00:06:16,910 --> 00:06:19,400
We'll get it to you later.

173
00:06:19,400 --> 00:06:22,190
[LAUGHTER]

174
00:06:22,190 --> 00:06:25,010
Deflate is actually comprised of two main compression algorithms.

175
00:06:25,010 --> 00:06:26,990
The first one is called LZ77.

176
00:06:26,990 --> 00:06:29,000
If you've watched my compressor head video,

177
00:06:29,000 --> 00:06:32,370
then you'll know that LZ77 is a dictionary algorithm that

178
00:06:32,370 --> 00:06:35,840
tries to match runs of duplicate characters

179
00:06:35,840 --> 00:06:38,900
multiple times in a stream of data.

180
00:06:38,900 --> 00:06:41,290
The output of that is then tossed to a Huffman encoder,

181
00:06:41,290 --> 00:06:42,780
which is a statistical encoder.

182
00:06:42,780 --> 00:06:44,710
If you've ever been to CS-101, you've

183
00:06:44,710 --> 00:06:46,630
probably dealt with Huffman in some form.

184
00:06:46,630 --> 00:06:48,400
Now this, again, is done on a single line.

185
00:06:48,400 --> 00:06:51,480
And the output of deflate is then kicked out to disk.

186
00:06:51,480 --> 00:06:55,330
Now what these two stages mean is very important.

187
00:06:55,330 --> 00:06:59,390
In areas of your image where there's very similar pixels,

188
00:06:59,390 --> 00:07:02,000
or there's a lot of duplicate pixels,

189
00:07:02,000 --> 00:07:04,590
that filtering stage is going to produce a lot of zeros.

190
00:07:04,590 --> 00:07:07,220
It's going to produce a lot of duplicate symbols, which

191
00:07:07,220 --> 00:07:09,017
means the lZ77 and the deflate stage

192
00:07:09,017 --> 00:07:12,020
are going to come through and basically make that stuff disappear.

193
00:07:12,020 --> 00:07:15,970
So areas of similarity are going to get great compression.

194
00:07:15,970 --> 00:07:17,770
However, areas of noise, where there's not

195
00:07:17,770 --> 00:07:19,810
a lot of similar pixels, where there's different colors that

196
00:07:19,810 --> 00:07:21,330
may not be adjoined to each other,

197
00:07:21,330 --> 00:07:23,580
are actually going to have worse compression.

198
00:07:23,580 --> 00:07:26,230
And that's what you get with this trade-off of the filtering

199
00:07:26,230 --> 00:07:29,380
stage with the deflate stage, right?

200
00:07:29,380 --> 00:07:32,370
Now, with this in mind, we can obviously

201
00:07:32,370 --> 00:07:35,300
see a couple of places that PNGs can be optimized

202
00:07:35,300 --> 00:07:36,800
a little bit more, right?

203
00:07:36,800 --> 00:07:39,010
The first, of course, is less input colors.

204
00:07:39,010 --> 00:07:41,960
If we've got less input colors coming into the filtering

205
00:07:41,960 --> 00:07:43,480
stage, that means that we're going

206
00:07:43,480 --> 00:07:45,340
to have less unique colors coming out,

207
00:07:45,340 --> 00:07:47,090
and we're going to get better compression.

208
00:07:47,090 --> 00:07:49,006
The other thing is actually smarter filtering.

209
00:07:49,006 --> 00:07:50,256
I won't get into it right now.

210
00:07:50,256 --> 00:07:51,547
There's a different post on it.

211
00:07:51,547 --> 00:07:53,557
But there's like five different filtering modes

212
00:07:53,557 --> 00:07:55,890
that the encoder can choose on and all that other stuff.

213
00:07:55,890 --> 00:07:58,760
And there's a lot of math and accelerations

214
00:07:58,760 --> 00:08:00,390
that go into finding that in a way

215
00:08:00,390 --> 00:08:02,764
that it's not going to take 10 years to compute it.

216
00:08:02,764 --> 00:08:04,680
The other thing is a better deflate algorithm.

217
00:08:04,680 --> 00:08:07,850
Now, believe or not, deflate isn't the best version of deflate.

218
00:08:07,850 --> 00:08:09,932
There's actually more modern deflates out there.

219
00:08:09,932 --> 00:08:12,723
And applying those to the algorithm actually produces smaller files.

220
00:08:12,723 --> 00:08:15,300
And finally, removing chunks-- and that's

221
00:08:15,300 --> 00:08:18,070
actually a tricky one that I'll get to in a minute.

222
00:08:18,070 --> 00:08:20,403
But I know what you're saying, like, hey, wait a minute,

223
00:08:20,403 --> 00:08:22,790
all of that stuff should be happening for me, right?

224
00:08:22,790 --> 00:08:25,164
I mean, there's this really cool tool in the Android tool

225
00:08:25,164 --> 00:08:26,704
chain called, AAPT.

226
00:08:26,704 --> 00:08:27,620
Anybody heard or that?

227
00:08:27,620 --> 00:08:28,619
Round of applause, yeah?

228
00:08:28,619 --> 00:08:29,376
[APPLAUSE]

229
00:08:29,376 --> 00:08:30,964
Yeah.

230
00:08:30,964 --> 00:08:33,629
I mean, in reality, this should be doing all that for you, right?

231
00:08:33,629 --> 00:08:36,390
It should be crunching your PNGS down as small as possible.

232
00:08:36,390 --> 00:08:39,179
Anyone seen that happen?

233
00:08:39,179 --> 00:08:39,679
Nobody?

234
00:08:39,679 --> 00:08:40,760
Some people?

235
00:08:40,760 --> 00:08:41,929
Someone's asleep already.

236
00:08:41,929 --> 00:08:42,532
One applause.

237
00:08:42,532 --> 00:08:43,490
Get that guy a t-shirt.

238
00:08:43,490 --> 00:08:44,760
[LAUGHTER]

239
00:08:44,760 --> 00:08:47,500
T-shirts for every clap. [LAUGHS]

240
00:08:47,500 --> 00:08:50,120
So I want to point out that, while the AAPT tool is there

241
00:08:50,120 --> 00:08:53,120
to actually try to make your PNG file smaller,

242
00:08:53,120 --> 00:08:55,690
it doesn't do everything it could.

243
00:08:55,690 --> 00:08:59,900
AAPT tool does three things specifically, no more, no less.

244
00:08:59,900 --> 00:09:02,390
The first thing it does is analyze your PNG files

245
00:09:02,390 --> 00:09:06,500
to see whether or not you're only using grayscale colors.

246
00:09:06,500 --> 00:09:08,860
So for example, if your red, green, blue channels

247
00:09:08,860 --> 00:09:11,120
are all the same color, it will actually

248
00:09:11,120 --> 00:09:15,340
make your entire image into a single, 8-bit alpha channel.

249
00:09:15,340 --> 00:09:15,840
That's it.

250
00:09:15,840 --> 00:09:17,090
Goes right down to gray scale.

251
00:09:17,090 --> 00:09:19,131
The second thing it'll look for is whether or not

252
00:09:19,131 --> 00:09:21,172
you're actually using your transparency channel.

253
00:09:21,172 --> 00:09:22,880
If you've got a fully opaque image that's

254
00:09:22,880 --> 00:09:24,940
not using any transparency bits, it'll

255
00:09:24,940 --> 00:09:28,250
actually get rid of that entire channel and save it out to be smaller.

256
00:09:28,250 --> 00:09:30,120
And the final thing-- and this is the one

257
00:09:30,120 --> 00:09:33,350
that's pretty awesome-- it'll actually scan your entire image

258
00:09:33,350 --> 00:09:39,600
and determine whether or not you're using 256 unique colors.

259
00:09:39,600 --> 00:09:42,020
If you're using 256 unique colors,

260
00:09:42,020 --> 00:09:44,720
it'll save your image in a palleted format,

261
00:09:44,720 --> 00:09:50,400
which basically decreases the size by some insane amount, right?

262
00:09:50,400 --> 00:09:53,120
Basically all of the 32-bit per pixel data

263
00:09:53,120 --> 00:09:56,190
gets quantized into a little table like that that we call a palette.

264
00:09:56,190 --> 00:09:58,900
And it's replaced with an 8-bit pointer into that palette.

265
00:09:58,900 --> 00:10:01,350
So instead of 32 bits per pixel, you're now down 8.

266
00:10:01,350 --> 00:10:02,501
Good savings, right?

267
00:10:02,501 --> 00:10:04,000
So the question that I have, though,

268
00:10:04,000 --> 00:10:07,610
is that OK, AAPT is really good, but how good is it?

269
00:10:07,610 --> 00:10:10,650
And the answer that, I had to open up an application

270
00:10:10,650 --> 00:10:14,230
and take a look at how AAPT was impacting and affecting

271
00:10:14,230 --> 00:10:15,855
that application, to see whether or not

272
00:10:15,855 --> 00:10:17,813
it was doing a really good job, or if there are

273
00:10:17,813 --> 00:10:19,310
some improvements to be made.

274
00:10:19,310 --> 00:10:21,170
So being I/O, I felt maybe we should

275
00:10:21,170 --> 00:10:23,970
do a callback to last year's I/O sched application

276
00:10:23,970 --> 00:10:26,830
and see how well AAPT was doing with that.

277
00:10:26,830 --> 00:10:28,430
So anyone look through the source code

278
00:10:28,430 --> 00:10:30,430
of the I/O scheduler application from last year?

279
00:10:30,430 --> 00:10:31,359
Round of applause?

280
00:10:31,359 --> 00:10:31,858
Yeah?

281
00:10:31,858 --> 00:10:32,794
[APPLAUSE]

282
00:10:32,794 --> 00:10:33,730
Good.

283
00:10:33,730 --> 00:10:36,660
Did anyone find the hidden Easter egg in the source code?

284
00:10:36,660 --> 00:10:37,246
No?

285
00:10:37,246 --> 00:10:37,920
Oh.

286
00:10:37,920 --> 00:10:39,295
Then forget I said anything.

287
00:10:39,295 --> 00:10:41,470
[LAUGHTER]

288
00:10:41,470 --> 00:10:43,760
So when we open up this file, there's a lot of assets.

289
00:10:43,760 --> 00:10:45,426
Now, there's two things to compare here.

290
00:10:45,426 --> 00:10:48,324
Of course, first is the source code files in GitHub,

291
00:10:48,324 --> 00:10:50,240
and then there's the APK that you can actually

292
00:10:50,240 --> 00:10:51,910
download from the Play Store, unzip, and take

293
00:10:51,910 --> 00:10:53,120
a look at the assets, right?

294
00:10:53,120 --> 00:10:54,970
So I wanted to look between these two,

295
00:10:54,970 --> 00:10:57,090
because if AAPT is doing a great job,

296
00:10:57,090 --> 00:11:00,540
I should see a big change between those two file sizes, right?

297
00:11:00,540 --> 00:11:02,926
So I opened up the file, and I just picked some random graphic.

298
00:11:02,926 --> 00:11:04,550
This was the one I happened to look at.

299
00:11:04,550 --> 00:11:08,250
That's a 144 x 140 pixel PNG file.

300
00:11:08,250 --> 00:11:10,630
And that's 6k.

301
00:11:10,630 --> 00:11:14,580
That's huge, right?

302
00:11:14,580 --> 00:11:16,540
Sorry, this is in the source code repo, right?

303
00:11:16,540 --> 00:11:18,623
Now, when I open up the APK and take a look at it,

304
00:11:18,623 --> 00:11:24,120
it's actually only 2k, which is better, but still way too big

305
00:11:24,120 --> 00:11:25,940
for 144 x 144 pixels.

306
00:11:25,940 --> 00:11:28,870
Like that's massively huge, right?

307
00:11:28,870 --> 00:11:32,500
And so I said, well, hold on, something's missing here.

308
00:11:32,500 --> 00:11:34,145
Obviously, we've got some optimization.

309
00:11:34,145 --> 00:11:35,520
Let's figure out what's going on.

310
00:11:35,520 --> 00:11:38,715
So I opened up this image in Photoshop, and I saved it for the web.

311
00:11:38,715 --> 00:11:42,360
There's a difference between file save and file save for web.

312
00:11:42,360 --> 00:11:44,190
There's a whole different process in there.

313
00:11:44,190 --> 00:11:48,071
In that process, I actually quantized it to only use 256 colors.

314
00:11:48,071 --> 00:11:49,570
And you can see, when I did that, we

315
00:11:49,570 --> 00:11:52,560
got about the same size as was in the APK.

316
00:11:52,560 --> 00:11:55,660
So we can see that, hey, the AAPT did its job.

317
00:11:55,660 --> 00:11:58,910
It probably quantized this to an indexed image, right?

318
00:11:58,910 --> 00:12:00,710
But here's the problem.

319
00:12:00,710 --> 00:12:01,950
Take a look at that image.

320
00:12:01,950 --> 00:12:04,980
Does it look like it's using 256 colors?

321
00:12:04,980 --> 00:12:05,580
No.

322
00:12:05,580 --> 00:12:07,400
So let's crank it down a little bit.

323
00:12:07,400 --> 00:12:08,970
Here's what 64 colors looks like.

324
00:12:08,970 --> 00:12:10,840
Anybody see a change?

325
00:12:10,840 --> 00:12:13,470
Let's go even more-- 16 colors.

326
00:12:13,470 --> 00:12:15,210
Still don't see a change.

327
00:12:15,210 --> 00:12:18,460
Eight colors, still don't see a change.

328
00:12:18,460 --> 00:12:21,470
Or if you do, your eyes are better than mine.

329
00:12:21,470 --> 00:12:23,940
The point here is that we went from 256 unique colors

330
00:12:23,940 --> 00:12:25,780
down to eight unique colors and didn't see

331
00:12:25,780 --> 00:12:27,430
a change in visual perception.

332
00:12:27,430 --> 00:12:31,310
The difference in file size though, was huge, right?

333
00:12:31,310 --> 00:12:35,210
Because we were able to find a smaller color size.

334
00:12:35,210 --> 00:12:38,270
So let's look at a different example here.

335
00:12:38,270 --> 00:12:40,460
So this is one of the big banner images

336
00:12:40,460 --> 00:12:42,150
that you see inside of the application.

337
00:12:42,150 --> 00:12:47,580
That's 49.5k in the GitHub repo, and 32k inside of the APK.

338
00:12:47,580 --> 00:12:51,670
So again, there's some smaller modifications going on here

339
00:12:51,670 --> 00:12:54,980
to the AAPT tool, but still, let's see if our trick

340
00:12:54,980 --> 00:12:56,240
works here too, right?

341
00:12:56,240 --> 00:12:59,660
So let's actually down-res it to 32 colors.

342
00:12:59,660 --> 00:13:01,740
This one isn't that good, right?

343
00:13:01,740 --> 00:13:04,612
I mean, you can see some banding in the gradients there.

344
00:13:04,612 --> 00:13:06,070
You can see that some of the colors

345
00:13:06,070 --> 00:13:08,280
just aren't looking as true as you can.

346
00:13:08,280 --> 00:13:11,440
So let's bump that up to exactly 256 colors.

347
00:13:11,440 --> 00:13:15,039
Here you can't actually see any visual difference, right?

348
00:13:15,039 --> 00:13:16,830
But notice the difference in the file size.

349
00:13:16,830 --> 00:13:20,420
This is only 18k, instead of the 36k, right?

350
00:13:20,420 --> 00:13:24,000
So this image actually only needed 256 colors,

351
00:13:24,000 --> 00:13:25,990
but maybe the source image didn't have that.

352
00:13:25,990 --> 00:13:28,700
And this is the problem with the AAPT tool.

353
00:13:28,700 --> 00:13:31,980
It does a great job of those exact three things,

354
00:13:31,980 --> 00:13:33,140
and no more than that.

355
00:13:33,140 --> 00:13:34,800
So in the first case, we had an image

356
00:13:34,800 --> 00:13:38,720
that obviously needed less colors and could have been optimized more.

357
00:13:38,720 --> 00:13:40,460
And in the second case, we had an image

358
00:13:40,460 --> 00:13:43,790
that had maybe just over 256 colors

359
00:13:43,790 --> 00:13:47,021
that, if we set it to 256, it still would have looked fine.

360
00:13:47,021 --> 00:13:47,520
Right?

361
00:13:47,520 --> 00:13:49,790
AAPT does neither of these for you,

362
00:13:49,790 --> 00:13:52,380
which means that it's your job, as a developer,

363
00:13:52,380 --> 00:13:54,080
to step past that and start doing

364
00:13:54,080 --> 00:13:57,970
additional methods to reduce the size of your PNG files.

365
00:13:57,970 --> 00:14:00,070
So let's take a look, as I said before,

366
00:14:00,070 --> 00:14:02,330
how easy it is to mess this up.

367
00:14:02,330 --> 00:14:08,270
So you actually just take a 16 pixel x 16 pixel all red PNG

368
00:14:08,270 --> 00:14:12,840
file, File, Save As from Photoshop, you look at 2k.

369
00:14:12,840 --> 00:14:17,599
That's 64 pixels, that 2k.

370
00:14:17,599 --> 00:14:19,140
The funny thing right now is everyone

371
00:14:19,140 --> 00:14:21,348
in the room is doing a gut check about whether or not

372
00:14:21,348 --> 00:14:24,060
their designers are using File, Save As from Photoshop

373
00:14:24,060 --> 00:14:26,050
to save their PNGs, right?

374
00:14:26,050 --> 00:14:27,419
Right? [CHUCKLES]

375
00:14:27,419 --> 00:14:28,960
When you save it for web, though, you

376
00:14:28,960 --> 00:14:31,930
end up at 121 bytes, which is better, which is obviously better.

377
00:14:31,930 --> 00:14:33,263
That's the thing we want to see.

378
00:14:33,263 --> 00:14:36,466
This is how easy it is to mess up this problem.

379
00:14:36,466 --> 00:14:38,090
Now, the good news is, though, that you

380
00:14:38,090 --> 00:14:40,247
don't have to go into crazy town with trying

381
00:14:40,247 --> 00:14:41,830
to optimize all those things we talked

382
00:14:41,830 --> 00:14:44,200
about before with the different stages of PNG.

383
00:14:44,200 --> 00:14:49,150
PNG optimization is an old problem, old meaning the 90s, right?

384
00:14:49,150 --> 00:14:52,350
I mean, some of you were alive in the 90s, right?

385
00:14:52,350 --> 00:14:52,850
[APPLAUSE]

386
00:14:52,850 --> 00:14:53,349
OK.

387
00:14:53,349 --> 00:14:54,430
Yeah.

388
00:14:54,430 --> 00:14:57,350
Who wasn't alive in the 90s?

389
00:14:57,350 --> 00:14:57,860
OK.

390
00:14:57,860 --> 00:14:58,470
All right.

391
00:14:58,470 --> 00:14:59,620
Yeah.

392
00:14:59,620 --> 00:15:00,170
Old people.

393
00:15:00,170 --> 00:15:00,944
Nice.

394
00:15:00,944 --> 00:15:01,840
[LAUGHTER]

395
00:15:01,840 --> 00:15:03,720
Sorry-- professional people.

396
00:15:03,720 --> 00:15:04,780
Yeah.

397
00:15:04,780 --> 00:15:07,354
The truth is that there is a plethora, a plethora of tools

398
00:15:07,354 --> 00:15:10,020
out there that have already been solving this problem for almost

399
00:15:10,020 --> 00:15:10,870
two decades.

400
00:15:10,870 --> 00:15:13,530
You don't got to do the heavy lifting, just Google it,

401
00:15:13,530 --> 00:15:15,330
and pick any one of these.

402
00:15:15,330 --> 00:15:15,830
Really.

403
00:15:15,830 --> 00:15:17,350
They all do different stuff, and have

404
00:15:17,350 --> 00:15:18,720
different algorithms, and different needs,

405
00:15:18,720 --> 00:15:20,219
and different settings, and whatnot.

406
00:15:20,219 --> 00:15:22,880
But if you just add any one of these to your existing asset

407
00:15:22,880 --> 00:15:25,060
chain, you're going to get an immediate reduction

408
00:15:25,060 --> 00:15:27,200
and an immediate improvement in file size.

409
00:15:27,200 --> 00:15:29,710
Now, that being said, there are some things

410
00:15:29,710 --> 00:15:33,810
that you can do to make it even better in terms of file sizes.

411
00:15:33,810 --> 00:15:36,210
And I only mention these two things

412
00:15:36,210 --> 00:15:38,767
because I'm seeing them a lot in applications

413
00:15:38,767 --> 00:15:40,350
that I'm opening and taking a look at.

414
00:15:40,350 --> 00:15:45,680
AKA here's the things you are all doing that you need to stop.

415
00:15:45,680 --> 00:15:49,110
So first off is, if you can, in every single way,

416
00:15:49,110 --> 00:15:55,430
try, try, try to make your image 256 colors or less.

417
00:15:55,430 --> 00:15:57,572
It's a pretty simple quantization step.

418
00:15:57,572 --> 00:15:58,280
You just test it.

419
00:15:58,280 --> 00:15:59,010
You take a look at it.

420
00:15:59,010 --> 00:16:00,384
Here is one of our Google doodles

421
00:16:00,384 --> 00:16:02,390
that we actually put on our main page here.

422
00:16:02,390 --> 00:16:05,020
You can see, it came down as 24 bits per pixel.

423
00:16:05,020 --> 00:16:07,710
It wasn't indexed at 197k.

424
00:16:07,710 --> 00:16:11,100
When we exported it at the index mode, it was only 73k.

425
00:16:11,100 --> 00:16:14,790
Again, visual difference here, imperceptible.

426
00:16:14,790 --> 00:16:16,960
But the difference in file size was huge,

427
00:16:16,960 --> 00:16:22,220
just by trying to take into account hitting that index mark.

428
00:16:22,220 --> 00:16:24,720
And you can see, the palette here is actually pretty simple.

429
00:16:24,720 --> 00:16:25,940
I mean, there's nothing crazy going on.

430
00:16:25,940 --> 00:16:28,500
By the way, that diamond down there on that white actually

431
00:16:28,500 --> 00:16:31,652
represents the transparent pixel color for that.

432
00:16:31,652 --> 00:16:33,360
And you can actually do a bunch of those.

433
00:16:33,360 --> 00:16:34,068
Read the article.

434
00:16:34,068 --> 00:16:35,640
There's more stuff on that there.

435
00:16:35,640 --> 00:16:36,920
Here's another one.

436
00:16:36,920 --> 00:16:39,860
Can anybody tell me why one of these images

437
00:16:39,860 --> 00:16:42,954
is 139 and one of these is 214?

438
00:16:42,954 --> 00:16:43,954
AUDIENCE: Alpha channel.

439
00:16:43,954 --> 00:16:45,120
COLT MCANLIS: Alpha channel.

440
00:16:45,120 --> 00:16:45,720
Good.

441
00:16:45,720 --> 00:16:46,928
What about the alpha channel?

442
00:16:46,928 --> 00:16:48,240
AUDIENCE: One of them's white.

443
00:16:48,240 --> 00:16:49,550
COLT MCANLIS: Wait, did you read the article?

444
00:16:49,550 --> 00:16:50,049
Oh, wait.

445
00:16:50,049 --> 00:16:50,984
Nevermind.

446
00:16:50,984 --> 00:16:51,790
Cheater.

447
00:16:51,790 --> 00:16:53,882
No, I'm kidding. [LAUGHS]

448
00:16:53,882 --> 00:16:55,590
So it's absolutely right-- alpha channel.

449
00:16:55,590 --> 00:16:56,890
So here's what's happening.

450
00:16:56,890 --> 00:16:59,890
I've seen this quite a bit in a lot of the files I've opened.

451
00:16:59,890 --> 00:17:03,450
So visually, you can see that the last frame

452
00:17:03,450 --> 00:17:04,770
is what the user sees here.

453
00:17:04,770 --> 00:17:06,895
But when you open this thing up and you take a look

454
00:17:06,895 --> 00:17:09,089
at the RGB channels and the A channels separately,

455
00:17:09,089 --> 00:17:10,540
you can see that the RGB actually

456
00:17:10,540 --> 00:17:14,140
has a ton of data that gets masked out by the alpha value.

457
00:17:14,140 --> 00:17:17,859
The end result is the same visual image to the user.

458
00:17:17,859 --> 00:17:23,420
But to the compressor, we still have to compress all of that RGB data.

459
00:17:23,420 --> 00:17:25,420
The filtering stage still has to be run on it.

460
00:17:25,420 --> 00:17:27,829
The output of that still has to be run through a deflate algorithm.

461
00:17:27,829 --> 00:17:30,540
And because there's a lot of non-uniform pixels there,

462
00:17:30,540 --> 00:17:33,540
the result is going to be a lot of bloat in your compressor, right?

463
00:17:33,540 --> 00:17:35,530
However, if we try to pre-multiply this stuff

464
00:17:35,530 --> 00:17:37,120
and mask out the pixels that we know

465
00:17:37,120 --> 00:17:40,900
are never going to be seen, we end up with a much smaller file size.

466
00:17:40,900 --> 00:17:43,480
I have been seeing this in applications popping up lately

467
00:17:43,480 --> 00:17:45,940
a lot more than I'd like to say.

468
00:17:45,940 --> 00:17:48,699
So take a look at this.

469
00:17:48,699 --> 00:17:50,740
Now, one of the final things I need to point out.

470
00:17:50,740 --> 00:17:52,281
If you're going to go down this path,

471
00:17:52,281 --> 00:17:55,249
and you're going to add in some of these awesome pre-processing

472
00:17:55,249 --> 00:17:57,540
tools to your chain and get it all working with Gradle,

473
00:17:57,540 --> 00:17:58,870
and you're going tell your designers to not

474
00:17:58,870 --> 00:18:01,245
do that thing I just said, and try to make indexed files,

475
00:18:01,245 --> 00:18:03,144
you may run into a really weird issue.

476
00:18:03,144 --> 00:18:04,810
So let's say we've got this great image.

477
00:18:04,810 --> 00:18:06,260
It's about 216k.

478
00:18:06,260 --> 00:18:09,070
And we actually run it through Zopfli PNG,

479
00:18:09,070 --> 00:18:11,810
which is a fantastic open source tool that

480
00:18:11,810 --> 00:18:15,200
is a better deflate algorithm compressor for PNG files.

481
00:18:15,200 --> 00:18:17,400
And we get it down to about 185k.

482
00:18:17,400 --> 00:18:20,180
But when you build it, it actually goes through AAPT,

483
00:18:20,180 --> 00:18:24,090
and it bloats to 201k.

484
00:18:24,090 --> 00:18:28,050
The reason for this is that the AAPT tool

485
00:18:28,050 --> 00:18:30,801
doesn't know that you've pre-processed your image.

486
00:18:30,801 --> 00:18:31,300
Right?

487
00:18:31,300 --> 00:18:33,554
Again, it's only checking for those three things.

488
00:18:33,554 --> 00:18:35,220
And so it's going to look at your image,

489
00:18:35,220 --> 00:18:38,287
and it's going to try to make it into A, B, or C format.

490
00:18:38,287 --> 00:18:40,370
And then it's just going to save it right to disk.

491
00:18:40,370 --> 00:18:41,510
The problem with that, though, is that you

492
00:18:41,510 --> 00:18:42,676
may have made modifications.

493
00:18:42,676 --> 00:18:46,210
And obviously, your version is smaller, and their version may not be.

494
00:18:46,210 --> 00:18:47,980
To get around this in your application,

495
00:18:47,980 --> 00:18:52,030
you need to specify the option Gradle, cruncherEnabled equals False.

496
00:18:52,030 --> 00:18:54,680
This will disable AAPT optimization

497
00:18:54,680 --> 00:18:57,190
for all of your PNG files that are coming though your pipe.

498
00:18:57,190 --> 00:18:59,477
Now the problem, though, is that, once you do this,

499
00:18:59,477 --> 00:19:01,810
it's kind of on you to make sure that all of your images

500
00:19:01,810 --> 00:19:02,730
are awesome at that point.

501
00:19:02,730 --> 00:19:03,230
Right?

502
00:19:03,230 --> 00:19:05,040
Which you're all going to do?

503
00:19:05,040 --> 00:19:08,400
[APPLAUSE]

504
00:19:08,400 --> 00:19:09,090
All right.

505
00:19:09,090 --> 00:19:10,533
Now the back row.

506
00:19:10,533 --> 00:19:13,371
[APPLAUSE]

507
00:19:13,371 --> 00:19:15,794
Now, let's try the front row again.

508
00:19:15,794 --> 00:19:17,582
[APPLAUSE]

509
00:19:17,582 --> 00:19:18,260
That was good.

510
00:19:18,260 --> 00:19:18,350
That was good.

511
00:19:18,350 --> 00:19:19,590
I'm sorry, the front row's winning.

512
00:19:19,590 --> 00:19:21,012
Back row, you want try again?

513
00:19:21,012 --> 00:19:22,370
[APPLAUSE AND WHISTLING]

514
00:19:22,370 --> 00:19:23,264
Oh.

515
00:19:23,264 --> 00:19:25,052
Oh.

516
00:19:25,052 --> 00:19:26,410
They added whistling.

517
00:19:26,410 --> 00:19:27,864
Come on, front row.

518
00:19:27,864 --> 00:19:28,780
We'll try again later.

519
00:19:28,780 --> 00:19:29,279
All right.

520
00:19:29,279 --> 00:19:31,200
The live stream's getting antsy. [LAUGHS]

521
00:19:31,200 --> 00:19:31,700
All right.

522
00:19:31,700 --> 00:19:34,054
So make sure that you actually set this configuration

523
00:19:34,054 --> 00:19:36,220
inside of your Gradle file, so that you don't end up

524
00:19:36,220 --> 00:19:38,053
actually bloating images that you've already

525
00:19:38,053 --> 00:19:39,677
taken the time to compress.

526
00:19:39,677 --> 00:19:42,010
Now, probably one of the biggest things that you can do,

527
00:19:42,010 --> 00:19:44,310
though, in terms of file savings, is actually

528
00:19:44,310 --> 00:19:49,120
consider replacing your PNGs altogether with vector drawables instead.

529
00:19:49,120 --> 00:19:53,110
Now, for those who don't know, PNG files are raster files.

530
00:19:53,110 --> 00:19:55,640
They have a big problem in that you need multiple of them

531
00:19:55,640 --> 00:19:57,430
in a file to actually get your images.

532
00:19:57,430 --> 00:19:59,469
So we need one at this resolution,

533
00:19:59,469 --> 00:20:01,760
and one at this resolution, and one at this resolution.

534
00:20:01,760 --> 00:20:03,385
Which means, in our APK, we're actually

535
00:20:03,385 --> 00:20:06,810
ending up at a 55k footprint to represent the same visual image

536
00:20:06,810 --> 00:20:08,110
at different resolutions.

537
00:20:08,110 --> 00:20:09,390
And there's some tricks you can play here

538
00:20:09,390 --> 00:20:11,870
with split APKs, and upsampling, and all this other stuff,

539
00:20:11,870 --> 00:20:13,570
but this is the gist of the problem.

540
00:20:13,570 --> 00:20:15,390
There's another way to approach this issue,

541
00:20:15,390 --> 00:20:18,386
and it's the concept of actually drawing your images with code.

542
00:20:18,386 --> 00:20:21,189
So that same picture-- what if we took a stab at it saying this.

543
00:20:21,189 --> 00:20:22,730
Let's admit a byte code that actually

544
00:20:22,730 --> 00:20:24,170
draws a white background, and then

545
00:20:24,170 --> 00:20:26,860
another code that actually draws a red circle.

546
00:20:26,860 --> 00:20:29,520
Now, if we create our custom DSL language and whatnot,

547
00:20:29,520 --> 00:20:32,430
we could actually get this into one byte per instruction

548
00:20:32,430 --> 00:20:36,752
and actually end up at about 15 bytes to represent the same thing.

549
00:20:36,752 --> 00:20:39,210
The result of this is that we can generate those same three

550
00:20:39,210 --> 00:20:43,570
images at any of these three sizes, using only 15 bytes of our scheme,

551
00:20:43,570 --> 00:20:46,200
instead of the 55k that we were using before.

552
00:20:46,200 --> 00:20:49,140
This is the concept of vector image formats.

553
00:20:49,140 --> 00:20:49,770
Right?

554
00:20:49,770 --> 00:20:51,710
Basically, we take some sort of stream

555
00:20:51,710 --> 00:20:54,340
that represents how to draw primitives on a screen,

556
00:20:54,340 --> 00:20:57,100
we actually execute those, rasterizing those primitives

557
00:20:57,100 --> 00:20:58,827
to a bitmap in CPU memory.

558
00:20:58,827 --> 00:21:00,410
We upload that to the GPU, and then we

559
00:21:00,410 --> 00:21:02,370
end up actually drawing that to the screen.

560
00:21:02,370 --> 00:21:05,670
The benefit you get here is much smaller file sizes.

561
00:21:05,670 --> 00:21:08,340
The downside, though, is you actually trade off time.

562
00:21:08,340 --> 00:21:10,710
It takes longer to rasterize these images

563
00:21:10,710 --> 00:21:13,050
and get them into memory than it does to actually,

564
00:21:13,050 --> 00:21:15,720
say, use the hardware decoder and decode a JPEG.

565
00:21:15,720 --> 00:21:17,786
So there's a little bit of a trade-off you have to deal with there.

566
00:21:17,786 --> 00:21:21,180
But this is the whole idea behind the Android's,

567
00:21:21,180 --> 00:21:22,500
vector drawable format.

568
00:21:22,500 --> 00:21:25,990
It's a series of instructions that

569
00:21:25,990 --> 00:21:28,350
define how to draw paths, and colors, and gradients,

570
00:21:28,350 --> 00:21:30,058
and all other sorts of stuff, so that you

571
00:21:30,058 --> 00:21:33,810
can draw these images at the sizes you need on demand.

572
00:21:33,810 --> 00:21:36,420
But the question is-- OK, this is fine, this is fancy,

573
00:21:36,420 --> 00:21:38,415
I've already got a pipeline of awesome PNGs

574
00:21:38,415 --> 00:21:40,010
and my artists know how to make PNGs.

575
00:21:40,010 --> 00:21:42,218
They don't know how to do this vector drawable thing.

576
00:21:42,218 --> 00:21:44,950
Come on, bald guy, let's get to the point here.

577
00:21:44,950 --> 00:21:46,280
What's really going on?

578
00:21:46,280 --> 00:21:47,010
Don't worry.

579
00:21:47,010 --> 00:21:48,690
So I decided to run a test.

580
00:21:48,690 --> 00:21:52,530
How much could vector drawables actually save me as a developer?

581
00:21:52,530 --> 00:21:55,795
To figure this out, though, I needed to take the I/O sched application

582
00:21:55,795 --> 00:21:58,580
and actually convert all of my images to vector drawables.

583
00:21:58,580 --> 00:22:03,780
Well, there's 270 of those things, totaling up to 926k in size.

584
00:22:03,780 --> 00:22:08,062
I don't have the time to hand customize all 270 of those images.

585
00:22:08,062 --> 00:22:09,770
Thankfully, there's a tool to the rescue.

586
00:22:09,770 --> 00:22:12,040
There's a great tool on the internet called Potrace.

587
00:22:12,040 --> 00:22:13,890
And this tool's been around a long time.

588
00:22:13,890 --> 00:22:16,240
It'll take a bitmap image, which is literally

589
00:22:16,240 --> 00:22:18,890
a image with 1-bit per pixel, and actually

590
00:22:18,890 --> 00:22:25,390
turn it into a vector format-- raster image to vector format.

591
00:22:25,390 --> 00:22:27,920
So I decided to run this on every asset inside the I/O

592
00:22:27,920 --> 00:22:28,980
sched application.

593
00:22:28,980 --> 00:22:31,080
And the results were actually a lot better

594
00:22:31,080 --> 00:22:33,244
than I expected, to be honest with you, right?

595
00:22:33,244 --> 00:22:35,160
So you can see the top row here is the source.

596
00:22:35,160 --> 00:22:38,400
And the bottom row here is the result of the Potrace application.

597
00:22:38,400 --> 00:22:39,530
We're pretty close.

598
00:22:39,530 --> 00:22:40,940
The first one looks identical.

599
00:22:40,940 --> 00:22:42,430
The second one, you can see some rounding.

600
00:22:42,430 --> 00:22:43,650
The third one, pretty good.

601
00:22:43,650 --> 00:22:46,210
The fourth one, you can see that we're only dealing with shapes,

602
00:22:46,210 --> 00:22:47,376
so we lose some color there.

603
00:22:47,376 --> 00:22:48,630
And the hexagon is perfect.

604
00:22:48,630 --> 00:22:50,840
The hexagon is actually a really cool example here,

605
00:22:50,840 --> 00:22:55,190
because that hexagon actually absorbed 6k of our file size

606
00:22:55,190 --> 00:22:56,350
at different resolutions.

607
00:22:56,350 --> 00:23:01,420
However, the vector version was only 961 bytes.

608
00:23:01,420 --> 00:23:04,330
So even just running it through here, we saw some wins.

609
00:23:04,330 --> 00:23:06,700
The downside, though, is that this is an automated tool.

610
00:23:06,700 --> 00:23:07,200
Right?

611
00:23:07,200 --> 00:23:08,130
I mean, this is only a test.

612
00:23:08,130 --> 00:23:09,970
We're just trying to figure out how all this stuff works together.

613
00:23:09,970 --> 00:23:11,710
And obviously, there were some failures.

614
00:23:11,710 --> 00:23:13,710
We missed some interspersion detail.

615
00:23:13,710 --> 00:23:16,190
Obviously, we're not getting the exact font representation.

616
00:23:16,190 --> 00:23:18,417
And it just fell over and died on the I/O algorithm.

617
00:23:18,417 --> 00:23:19,610
Right?

618
00:23:19,610 --> 00:23:22,540
The result, though, I think, was a good test

619
00:23:22,540 --> 00:23:24,450
to figure out what you could save.

620
00:23:24,450 --> 00:23:26,220
So running things through Potrace,

621
00:23:26,220 --> 00:23:28,820
we actually ended up with only 153 files,

622
00:23:28,820 --> 00:23:31,960
because we didn't have to have one for each resolution.

623
00:23:31,960 --> 00:23:34,620
And the result was actually 149k.

624
00:23:34,620 --> 00:23:37,770
That's 84% reduction in asset sizes,

625
00:23:37,770 --> 00:23:41,160
by just moving everything to be a vector drawable, which

626
00:23:41,160 --> 00:23:42,980
is a pretty good savings.

627
00:23:42,980 --> 00:23:43,480
Yes.

628
00:23:43,480 --> 00:23:44,030
Let's clap.

629
00:23:44,030 --> 00:23:44,310
Yes.

630
00:23:44,310 --> 00:23:44,810
[APPLAUSE]

631
00:23:44,810 --> 00:23:45,600
This man.

632
00:23:45,600 --> 00:23:47,347
Yes.

633
00:23:47,347 --> 00:23:48,430
You started the clap, sir.

634
00:23:48,430 --> 00:23:49,562
You are awesome.

635
00:23:49,562 --> 00:23:50,190
Fantastic.

636
00:23:50,190 --> 00:23:50,690
Yeah.

637
00:23:50,690 --> 00:23:53,137
So 84% smaller, that's a pretty good deal, right?

638
00:23:53,137 --> 00:23:54,970
Now, it's worth noting this was just a test.

639
00:23:54,970 --> 00:23:58,140
You can't just go run Potrace and convert everything over.

640
00:23:58,140 --> 00:24:01,291
I mean, it spits out EPS files, and that's not the same as VD files.

641
00:24:01,291 --> 00:24:03,165
And oh, by the way, there's actually a chance

642
00:24:03,165 --> 00:24:04,890
that you could optimize stuff further.

643
00:24:04,890 --> 00:24:07,500
Instead of just importing from SVG, if you did stuff by hand,

644
00:24:07,500 --> 00:24:10,366
you may actually be able to get stuff down even smaller than that.

645
00:24:10,366 --> 00:24:12,490
But the main point is, you can get a lot of savings

646
00:24:12,490 --> 00:24:14,450
here by moving to vector drawables,

647
00:24:14,450 --> 00:24:17,390
so make sure you take a look at it.

648
00:24:17,390 --> 00:24:21,560
Now, let's talk about the big images, the big, big images, JPEGs.

649
00:24:21,560 --> 00:24:22,500
Who loves JPEGs?

650
00:24:22,500 --> 00:24:23,428
[APPLAUSE]

651
00:24:23,428 --> 00:24:25,251
Yeah?

652
00:24:25,251 --> 00:24:25,750
Yep.

653
00:24:25,750 --> 00:24:27,166
I didn't hear anybody in the back.

654
00:24:27,166 --> 00:24:30,615
[APPLAUSE]

655
00:24:30,615 --> 00:24:32,546
[LAUGHS] I love the begrudging pause.

656
00:24:32,546 --> 00:24:33,046
Right?

657
00:24:33,046 --> 00:24:34,002
Like, ugh.

658
00:24:34,002 --> 00:24:35,440
Fine.

659
00:24:35,440 --> 00:24:37,903
We're just here to stay out of the heat. [LAUGHS]

660
00:24:37,903 --> 00:24:39,350
[LAUGHTER]

661
00:24:39,350 --> 00:24:40,215
Pass me some water.

662
00:24:40,215 --> 00:24:41,480
This is great.

663
00:24:41,480 --> 00:24:47,500
OK, JPEG files-- I've got to tell you, JPEGS are-- they're crazy.

664
00:24:47,500 --> 00:24:54,040
One of the most impressive algorithmic systems I've ever encountered.

665
00:24:54,040 --> 00:24:57,730
It's impressive the math that goes into this, not just

666
00:24:57,730 --> 00:25:02,017
from an algorithm perspective, but just the raw math of the situation.

667
00:25:02,017 --> 00:25:02,850
Take a look at this.

668
00:25:02,850 --> 00:25:05,500
So when you encode a JPEG, here's what's going on.

669
00:25:05,500 --> 00:25:07,094
You take your source RGB image.

670
00:25:07,094 --> 00:25:09,510
And the first thing that happens is we actually convert it

671
00:25:09,510 --> 00:25:11,190
to a separate color space.

672
00:25:11,190 --> 00:25:13,480
The reason for this is the human eye,

673
00:25:13,480 --> 00:25:16,120
the psycho-visual differences in the human eye

674
00:25:16,120 --> 00:25:20,690
are less susceptible to the YCBCR color

675
00:25:20,690 --> 00:25:23,040
space, or the chroma luminance color space.

676
00:25:23,040 --> 00:25:23,554
Right?

677
00:25:23,554 --> 00:25:25,845
We're actually more tuned-- the human eye is more tuned

678
00:25:25,845 --> 00:25:29,140
to see differences in RGBs, than we are YCBCR,

679
00:25:29,140 --> 00:25:32,940
so the first thing the JPEG does is convert it to that space.

680
00:25:32,940 --> 00:25:34,620
The next thing is we actually reduce

681
00:25:34,620 --> 00:25:38,240
the size of the CB, the chroma channels, CB and CR channels.

682
00:25:38,240 --> 00:25:41,680
Again, the human eye doesn't notice as much changes in that spectrum,

683
00:25:41,680 --> 00:25:43,175
so it doesn't worry about it.

684
00:25:43,175 --> 00:25:45,550
After that, we actually go through and block up our image

685
00:25:45,550 --> 00:25:48,850
and apply the discrete cosine transform.

686
00:25:48,850 --> 00:25:51,710
This is magical.

687
00:25:51,710 --> 00:25:54,270
If you get a chance to check out the blog post on this,

688
00:25:54,270 --> 00:25:57,370
basically, the idea of the discrete cosine transform

689
00:25:57,370 --> 00:26:03,500
is that any signal can be represented by a sum of cosines.

690
00:26:03,500 --> 00:26:04,830
What?

691
00:26:04,830 --> 00:26:06,070
It's a thing.

692
00:26:06,070 --> 00:26:06,690
It's a thing.

693
00:26:06,690 --> 00:26:08,940
Like these mathematicians sat down and worked that out

694
00:26:08,940 --> 00:26:10,880
on paper, before computers were awesome.

695
00:26:10,880 --> 00:26:12,890
Like, discrete cosine transform is

696
00:26:12,890 --> 00:26:15,240
one of the most amazing things I have ever seen.

697
00:26:15,240 --> 00:26:18,290
Basically, they can represent any 8 x 8 block of pixels

698
00:26:18,290 --> 00:26:21,470
by summing cosine transforms across a 2D space.

699
00:26:21,470 --> 00:26:23,520
That is awesome, right?

700
00:26:23,520 --> 00:26:26,129
The output of that is then ran into a quantization phase.

701
00:26:26,129 --> 00:26:27,920
The quantization phase just basically takes

702
00:26:27,920 --> 00:26:29,420
the output of the basis coefficients

703
00:26:29,420 --> 00:26:31,470
and quantizes them down to integers in a subspace

704
00:26:31,470 --> 00:26:32,500
that we can actually encode more.

705
00:26:32,500 --> 00:26:34,583
Then it gets sent out to this statistical encoding

706
00:26:34,583 --> 00:26:37,520
phase, which may be Huffman, or arithmetic,

707
00:26:37,520 --> 00:26:39,940
or whatever your particular flavor of the month is.

708
00:26:39,940 --> 00:26:43,150
And then finally, of course, we go to the output JPEG file.

709
00:26:43,150 --> 00:26:44,690
Now, here's the weird thing.

710
00:26:44,690 --> 00:26:46,640
This is awesome.

711
00:26:46,640 --> 00:26:48,730
This is totally crazy, right?

712
00:26:48,730 --> 00:26:50,900
Way harder than PNG.

713
00:26:50,900 --> 00:26:54,020
Then why, when you export an image, you're given like one slider?

714
00:26:54,020 --> 00:26:57,620
[LAUGHTER]

715
00:26:57,620 --> 00:27:00,450
All of this chaos is hidden behind one slider

716
00:27:00,450 --> 00:27:02,460
when you export an image.

717
00:27:02,460 --> 00:27:04,320
That's impressive on its own right.

718
00:27:04,320 --> 00:27:06,320
Now, the question is, what should this value be?

719
00:27:06,320 --> 00:27:07,500
This is the JPEG quality.

720
00:27:07,500 --> 00:27:09,290
When you export a JPEG, we ask you

721
00:27:09,290 --> 00:27:11,534
what quality you want it outputted at, right?

722
00:27:11,534 --> 00:27:13,200
So the question is, what should this be?

723
00:27:13,200 --> 00:27:13,700
Right?

724
00:27:13,700 --> 00:27:16,470
So let's take a visual look at what Photoshop would actually

725
00:27:16,470 --> 00:27:17,310
output as.

726
00:27:17,310 --> 00:27:20,910
So here's PS12, so this it would be 100% JPEG quality.

727
00:27:20,910 --> 00:27:21,580
Right?

728
00:27:21,580 --> 00:27:22,960
263k.

729
00:27:22,960 --> 00:27:28,224
Let's drop down to 11, 10, go to 8.

730
00:27:28,224 --> 00:27:29,890
You can start seeing some blocking here.

731
00:27:29,890 --> 00:27:32,257
Look right above the red parrot's head.

732
00:27:32,257 --> 00:27:34,090
You can start seeing some ringing artifacts.

733
00:27:34,090 --> 00:27:36,440
The gradients in the background aren't as solid there.

734
00:27:36,440 --> 00:27:39,180
Let's go down to 4.

735
00:27:39,180 --> 00:27:40,370
So this is quality 4.

736
00:27:40,370 --> 00:27:42,120
You see a lot more ringing artifacts here.

737
00:27:42,120 --> 00:27:42,750
Right?

738
00:27:42,750 --> 00:27:45,010
You can start seeing the quantization artifacts

739
00:27:45,010 --> 00:27:46,830
in each 8 x 8 block, right?

740
00:27:46,830 --> 00:27:48,220
And zero.

741
00:27:48,220 --> 00:27:49,940
Obviously, some color bleeding going on.

742
00:27:49,940 --> 00:27:51,470
We're seeing some big stuff there.

743
00:27:51,470 --> 00:27:55,430
So the question is, though, what value should I choose?

744
00:27:55,430 --> 00:27:55,930
Right?

745
00:27:55,930 --> 00:27:57,639
I mean, you can't open every single image

746
00:27:57,639 --> 00:27:59,679
and take a look at it and choose the right value.

747
00:27:59,679 --> 00:28:04,300
There's just no way we can support that in any sort of real pipeline.

748
00:28:04,300 --> 00:28:07,360
The solution is to not, it's to automate the whole process.

749
00:28:07,360 --> 00:28:10,322
And for that-- I'll get to it in another slide.

750
00:28:10,322 --> 00:28:13,640
[LAUGHS] The real solution here is to automate this process

751
00:28:13,640 --> 00:28:14,390
and figure it out.

752
00:28:14,390 --> 00:28:15,950
But that's actually not what most people are doing.

753
00:28:15,950 --> 00:28:17,690
What most people are actually doing here,

754
00:28:17,690 --> 00:28:21,150
is choosing some value and exporting all of their images at that.

755
00:28:21,150 --> 00:28:23,067
The ImgMin project, which is an open source

756
00:28:23,067 --> 00:28:25,650
project on the internet, started downloading a bunch of images

757
00:28:25,650 --> 00:28:27,024
from all of these social networks

758
00:28:27,024 --> 00:28:29,800
and figuring out what their exported quality was, and then

759
00:28:29,800 --> 00:28:31,240
put it together in a table.

760
00:28:31,240 --> 00:28:34,270
So you can actually see what everyone is exporting things at.

761
00:28:34,270 --> 00:28:36,780
Now, the ones with ranges are actually really impressive,

762
00:28:36,780 --> 00:28:39,300
because it means that they're trying to actually find

763
00:28:39,300 --> 00:28:40,440
the right range of things.

764
00:28:40,440 --> 00:28:42,732
The weird thing is it's not as scalable as you'd think.

765
00:28:42,732 --> 00:28:43,231
Right?

766
00:28:43,231 --> 00:28:46,150
Like if something happens to be brighter, it's given these values.

767
00:28:46,150 --> 00:28:47,566
If it's darker, it's these values.

768
00:28:47,566 --> 00:28:49,560
It's a little bit more quantized than dynamic.

769
00:28:49,560 --> 00:28:50,934
But the question for your project

770
00:28:50,934 --> 00:28:53,500
is, how do we figure this out algorithmically?

771
00:28:53,500 --> 00:28:56,560
And for that, I want to introduce Butteraugli.

772
00:28:56,560 --> 00:28:59,160
This is an open source project made by the compression

773
00:28:59,160 --> 00:29:01,550
team in Zurich who loves naming things so

774
00:29:01,550 --> 00:29:03,263
that I can't Google for them.

775
00:29:03,263 --> 00:29:04,030
[LAUGHTER]

776
00:29:04,030 --> 00:29:05,630
--or spell them or pronounce them.

777
00:29:05,630 --> 00:29:07,220
So to make sure that you all can pronounce it,

778
00:29:07,220 --> 00:29:08,890
we're going to say it together here, OK?

779
00:29:08,890 --> 00:29:10,912
This is going to be boo-- AUDIENCE: Boo--

780
00:29:10,912 --> 00:29:12,526
COLT MCANLIS: Ter-- AUDIENCE: Ter--

781
00:29:12,526 --> 00:29:14,230
COLT MCANLIS: Aug-- AUDIENCE: Aug--

782
00:29:14,230 --> 00:29:15,245
COLT MCANLIS: Lee-- AUDIENCE: Lee.

783
00:29:15,245 --> 00:29:16,328
COLT MCANLIS: Butteraugli.

784
00:29:16,328 --> 00:29:17,442
AUDIENCE: Butteraugli.

785
00:29:17,442 --> 00:29:18,150
COLT MCANLIS: OK.

786
00:29:18,150 --> 00:29:19,940
Now, you all can Google this later.

787
00:29:19,940 --> 00:29:23,240
In the native language, it means a sweet bread to eat with coffee.

788
00:29:23,240 --> 00:29:25,850
But in the GitHub project, it means a way

789
00:29:25,850 --> 00:29:29,900
to compare the psycho-visual similarity of two images.

790
00:29:29,900 --> 00:29:32,030
This is basically a way for us to say,

791
00:29:32,030 --> 00:29:34,750
let me take a source image and compress it

792
00:29:34,750 --> 00:29:37,530
and see how the human eye responds to the differences

793
00:29:37,530 --> 00:29:38,280
between these two.

794
00:29:38,280 --> 00:29:40,482
How much error can we actually notice?

795
00:29:40,482 --> 00:29:44,154
Now, you may have heard some other terms in the past, like PSNR.

796
00:29:44,154 --> 00:29:45,070
Anybody hear that one?

797
00:29:45,070 --> 00:29:45,970
Yeah?

798
00:29:45,970 --> 00:29:46,470
SSIM?

799
00:29:46,470 --> 00:29:46,970
Yeah?

800
00:29:46,970 --> 00:29:47,680
These are common.

801
00:29:47,680 --> 00:29:48,180
Yeah?

802
00:29:48,180 --> 00:29:48,610
Nice.

803
00:29:48,610 --> 00:29:49,818
These are very common things.

804
00:29:49,818 --> 00:29:52,020
Think of Butteraugli in the same fashion of that,

805
00:29:52,020 --> 00:29:55,490
the ability to measure two different psycho-visual changes

806
00:29:55,490 --> 00:29:57,480
as an image changes.

807
00:29:57,480 --> 00:30:01,760
Now, the real use of Butteraugli, the intention that it was made for,

808
00:30:01,760 --> 00:30:04,890
was to actually figure out how much we

809
00:30:04,890 --> 00:30:08,013
can compress an image before the human eye notices anything.

810
00:30:08,013 --> 00:30:08,800
Right?

811
00:30:08,800 --> 00:30:12,210
How far can we go before even the smallest perceived

812
00:30:12,210 --> 00:30:13,117
visual change occurs?

813
00:30:13,117 --> 00:30:15,200
And when you actually use the Butteraugli library,

814
00:30:15,200 --> 00:30:17,810
you'll notice that that actually occurs at the 1.0 level.

815
00:30:17,810 --> 00:30:20,490
So when you export at Butteraugli 1.0,

816
00:30:20,490 --> 00:30:22,660
that is where-- or when you test it

817
00:30:22,660 --> 00:30:25,467
and you get 1.0, that is where the human eye starts

818
00:30:25,467 --> 00:30:26,300
to notice artifacts.

819
00:30:26,300 --> 00:30:28,710
Anything above 1.0 is chaos land.

820
00:30:28,710 --> 00:30:31,411
Anything below 1.0, the human eye can't decipher.

821
00:30:31,411 --> 00:30:31,910
Right?

822
00:30:31,910 --> 00:30:34,770
So your goal would be like, hey, we have a lot of high res images.

823
00:30:34,770 --> 00:30:37,900
We want high res images, and we want to find the ideal export.

824
00:30:37,900 --> 00:30:39,080
This will help you.

825
00:30:39,080 --> 00:30:42,010
But sometimes, I don't want perfection.

826
00:30:42,010 --> 00:30:42,799
Right?

827
00:30:42,799 --> 00:30:45,630
Sometimes, I want a little bit of compression artifacts in there.

828
00:30:45,630 --> 00:30:47,990
Sometimes, someone's loading something on a 2G network,

829
00:30:47,990 --> 00:30:49,550
or they're sitting on roaming, or they're

830
00:30:49,550 --> 00:30:51,716
in the middle of India and they don't have the right

831
00:30:51,716 --> 00:30:54,227
connectivity, I want to give them a worse quality image,

832
00:30:54,227 --> 00:30:56,560
so it doesn't take them six hours to download the thing.

833
00:30:56,560 --> 00:30:57,060
Right?

834
00:30:57,060 --> 00:30:58,350
They don't have to pay for it.

835
00:30:58,350 --> 00:31:00,910
So maybe I'm OK going above 1.0.

836
00:31:00,910 --> 00:31:04,090
So how would we go about doing something like this?

837
00:31:04,090 --> 00:31:07,780
How would we find the right level for some other statistic?

838
00:31:07,780 --> 00:31:09,030
And it's actually pretty easy.

839
00:31:09,030 --> 00:31:11,321
If we actually take a little Python script here and run

840
00:31:11,321 --> 00:31:14,860
ImageMagick, we can convert a PNG to a JPEG file at some quality.

841
00:31:14,860 --> 00:31:15,760
Right?

842
00:31:15,760 --> 00:31:18,430
We convert that JPEG back to a PNG,

843
00:31:18,430 --> 00:31:21,580
so we know we're actually comparing apples to apples here.

844
00:31:21,580 --> 00:31:24,340
And then we run those two PNG files through Butteraugli.

845
00:31:24,340 --> 00:31:26,820
And if the score is above some random metric

846
00:31:26,820 --> 00:31:29,320
that we've decided, based upon artificial intelligence

847
00:31:29,320 --> 00:31:31,700
and machine learning for this person, in this area,

848
00:31:31,700 --> 00:31:34,790
on this device-- let's just say it's 2.0,

849
00:31:34,790 --> 00:31:37,360
randomly-- then we return that quality value.

850
00:31:37,360 --> 00:31:39,280
So what does this look like?

851
00:31:39,280 --> 00:31:40,810
So I ran this on the parrots images.

852
00:31:40,810 --> 00:31:42,710
And you can see, really quickly, we

853
00:31:42,710 --> 00:31:46,545
found that, about quality 60, we passed the 2.0 threshold.

854
00:31:46,545 --> 00:31:47,700
Right?

855
00:31:47,700 --> 00:31:50,550
And then, it actually was able to dive in a little bit more

856
00:31:50,550 --> 00:31:52,720
and get single-step quantization.

857
00:31:52,720 --> 00:31:56,770
Actually found that, at quality 62, we broke the 2.0 threshold.

858
00:31:56,770 --> 00:31:59,140
Let's look at this side by side.

859
00:31:59,140 --> 00:32:01,430
This is the 1.0 score and the 2.0 score.

860
00:32:01,430 --> 00:32:03,520
The difference is 60k.

861
00:32:03,520 --> 00:32:04,030
Right?

862
00:32:04,030 --> 00:32:07,550
But the Butteraugli image metric is so nice

863
00:32:07,550 --> 00:32:11,294
that you can see very small changes in the 2.0 version.

864
00:32:11,294 --> 00:32:13,960
Of course, this is blown up on a screen, and on the live stream,

865
00:32:13,960 --> 00:32:15,080
and all this other stuff.

866
00:32:15,080 --> 00:32:17,121
But the main point that I'm trying to get to here

867
00:32:17,121 --> 00:32:20,930
is that you don't have to choose one image compression

868
00:32:20,930 --> 00:32:21,970
quality for everything.

869
00:32:21,970 --> 00:32:25,560
You can actually dynamically choose this and move on.

870
00:32:25,560 --> 00:32:27,930
So beyond that, though, there's a couple of things

871
00:32:27,930 --> 00:32:31,040
that you can do by hand.

872
00:32:31,040 --> 00:32:33,730
JPEG, unfortunately, has the same problem that PNG does.

873
00:32:33,730 --> 00:32:34,340
Right?

874
00:32:34,340 --> 00:32:40,440
File, Save As from Photoshop, 11k for that 16 x 16 pixel block.

875
00:32:40,440 --> 00:32:41,970
11k!

876
00:32:41,970 --> 00:32:43,310
Ugh!

877
00:32:43,310 --> 00:32:45,366
Are you sure your designers aren't doing that?

878
00:32:45,366 --> 00:32:46,220
[LAUGHTER]

879
00:32:46,220 --> 00:32:48,130
Are you really sure?

880
00:32:48,130 --> 00:32:49,470
Think about it.

881
00:32:49,470 --> 00:32:51,300
Maybe send a text real quick.

882
00:32:51,300 --> 00:32:52,270
[LAUGHTER]

883
00:32:52,270 --> 00:32:53,240
Yeah?

884
00:32:53,240 --> 00:32:56,030
Save As gets us to 1.1k.

885
00:32:56,030 --> 00:33:00,760
Still, that's a 16 pixel x 16 pixel image.

886
00:33:00,760 --> 00:33:03,910
The funny thing is-- you want to know what's going on here?

887
00:33:03,910 --> 00:33:06,950
Extra data, Metadata.

888
00:33:06,950 --> 00:33:10,651
JPEGs and PNGs have the ability to add block data to your image.

889
00:33:10,651 --> 00:33:12,400
So when I'm standing on the Google campus,

890
00:33:12,400 --> 00:33:13,710
wandering around, because it's Google I/O,

891
00:33:13,710 --> 00:33:14,980
and I take a picture of the Gator.

892
00:33:14,980 --> 00:33:18,292
This is how my image sharing service knows where I was standing.

893
00:33:18,292 --> 00:33:19,750
There's blocks that they can insert

894
00:33:19,750 --> 00:33:22,780
into your JPEG files that have this location-based information.

895
00:33:22,780 --> 00:33:23,972
And that bloats your image.

896
00:33:23,972 --> 00:33:25,930
And if you're not properly removing this stuff,

897
00:33:25,930 --> 00:33:27,280
as an image serving application, that

898
00:33:27,280 --> 00:33:29,590
means every other user who's downloading it is grabbing

899
00:33:29,590 --> 00:33:31,350
this extra bloated data.

900
00:33:31,350 --> 00:33:33,712
Obviously, that's not a good idea.

901
00:33:33,712 --> 00:33:35,920
So let's talk about-- that's obviously block removal,

902
00:33:35,920 --> 00:33:38,190
but there's a bunch of other places that we can optimize here, right?

903
00:33:38,190 --> 00:33:39,731
We can change how we're downsampling.

904
00:33:39,731 --> 00:33:43,520
We can improve the way that the DCT coefficients are handled.

905
00:33:43,520 --> 00:33:45,114
We can improve the way we quantize.

906
00:33:45,114 --> 00:33:47,280
Or we could just apply a better statistical encoder.

907
00:33:47,280 --> 00:33:47,860
Right?

908
00:33:47,860 --> 00:33:48,742
Great news, folks.

909
00:33:48,742 --> 00:33:50,450
You don't got to worry about any of that.

910
00:33:50,450 --> 00:33:52,270
Everybody's already got it solved.

911
00:33:52,270 --> 00:33:55,150
Googling for this brings you a pretty good handful

912
00:33:55,150 --> 00:33:58,500
of algorithms and tools that you can put right into your tool chain.

913
00:33:58,500 --> 00:34:00,830
The first two here, JPEGMini and MozJPEG,

914
00:34:00,830 --> 00:34:05,210
actually go to find another lossy compression variant.

915
00:34:05,210 --> 00:34:07,350
So they'll degrade the image quality

916
00:34:07,350 --> 00:34:09,719
of your image to get you just a little bit farther

917
00:34:09,719 --> 00:34:11,030
and a little bit more savings.

918
00:34:11,030 --> 00:34:11,530
Right?

919
00:34:11,530 --> 00:34:14,449
On the other two, cJPEG and packJPG are lossless.

920
00:34:14,449 --> 00:34:16,630
They're going to try to improve those quantization

921
00:34:16,630 --> 00:34:19,560
and statistical encoding stages, so that you don't actually

922
00:34:19,560 --> 00:34:20,590
lose any bits.

923
00:34:20,590 --> 00:34:23,030
The interesting thing is that packJPG actually works more

924
00:34:23,030 --> 00:34:24,480
as a post format than anything.

925
00:34:24,480 --> 00:34:26,409
It'll actually take your JPEG and encode it

926
00:34:26,409 --> 00:34:28,869
in its own format, so we can get it even smaller than that.

927
00:34:28,869 --> 00:34:30,739
And of course, you've got a lot of web solutions

928
00:34:30,739 --> 00:34:32,440
that you can find too where you upload

929
00:34:32,440 --> 00:34:34,109
your image to some API or some service,

930
00:34:34,109 --> 00:34:36,400
it'll do everything on the back end and send it to you.

931
00:34:36,400 --> 00:34:38,090
I don't care what you use.

932
00:34:38,090 --> 00:34:40,110
Pick one, right?

933
00:34:40,110 --> 00:34:43,440
And don't let your designers hit Save As from Photoshop.

934
00:34:43,440 --> 00:34:43,940
Right?

935
00:34:43,940 --> 00:34:44,930
Any of these will work.

936
00:34:44,930 --> 00:34:45,429
Pick one.

937
00:34:45,429 --> 00:34:45,969
Test it out.

938
00:34:45,969 --> 00:34:46,620
See how it works.

939
00:34:46,620 --> 00:34:48,495
Send me a tweet, let me know how it happened.

940
00:34:48,495 --> 00:34:49,211
Right?

941
00:34:49,211 --> 00:34:49,960
One thing, though.

942
00:34:49,960 --> 00:34:51,730
I've got to say, this one's really cool to do by hand.

943
00:34:51,730 --> 00:34:52,770
And I've only got a couple minutes,

944
00:34:52,770 --> 00:34:54,603
so I'm going to try to go through this fast.

945
00:34:54,603 --> 00:35:00,000
Two images here, top one 175, Colt-modified, 82k on the bottom.

946
00:35:00,000 --> 00:35:03,080
What we're doing here-- remember that the first thing that JPEG

947
00:35:03,080 --> 00:35:05,980
does is split your image into a different color space,

948
00:35:05,980 --> 00:35:09,140
because the human eye is more perceptible to some loss than others.

949
00:35:09,140 --> 00:35:11,560
So what we do here is, we actually, in Photoshop, split

950
00:35:11,560 --> 00:35:12,710
this to LAB color mode.

951
00:35:12,710 --> 00:35:13,210
Right?

952
00:35:13,210 --> 00:35:14,910
Which is luminance and then AB channels.

953
00:35:14,910 --> 00:35:17,440
We select the areas of high contrast inside of the AB

954
00:35:17,440 --> 00:35:20,726
channels, and we actually just go File Blur.

955
00:35:20,726 --> 00:35:22,350
What we're doing here is we're actually

956
00:35:22,350 --> 00:35:26,250
reducing the number of unique colors, the amount of noise

957
00:35:26,250 --> 00:35:31,380
in these chroma channels, so that when the JPEG codec comes

958
00:35:31,380 --> 00:35:33,510
back through, there's less information there

959
00:35:33,510 --> 00:35:34,720
that it has to find unique.

960
00:35:34,720 --> 00:35:36,820
And you're actually going to get better compression as a result.

961
00:35:36,820 --> 00:35:38,550
So this simple technique, going through,

962
00:35:38,550 --> 00:35:40,027
hand optimizing some of this stuff,

963
00:35:40,027 --> 00:35:41,610
can actually save you-- what was this?

964
00:35:41,610 --> 00:35:45,490
2x or 50% savings on a file?

965
00:35:45,490 --> 00:35:48,310
If you're serving a million files a day, that's huge.

966
00:35:48,310 --> 00:35:49,870
Right?

967
00:35:49,870 --> 00:35:50,380
All right.

968
00:35:50,380 --> 00:35:52,520
Let's get to the final one here-- WebP.

969
00:35:52,520 --> 00:35:53,127
Fans of WebP?

970
00:35:53,127 --> 00:35:54,070
[APPLAUSE]

971
00:35:54,070 --> 00:35:54,570
Yeah?

972
00:35:57,881 --> 00:35:58,827
Yes.

973
00:35:58,827 --> 00:36:02,280
WebP, I've got to say, as impressive as JPEG

974
00:36:02,280 --> 00:36:05,420
is, WebP is in its own league.

975
00:36:05,420 --> 00:36:07,380
I've done compression for a long time.

976
00:36:07,380 --> 00:36:08,990
It's in its own league.

977
00:36:08,990 --> 00:36:12,650
I mean, on one side, you've got a whole suite of algorithms

978
00:36:12,650 --> 00:36:15,410
that applies, so we can keep up with the lossy type

979
00:36:15,410 --> 00:36:16,661
of compression that JPEG does.

980
00:36:16,661 --> 00:36:18,035
On the other side of it, it's got

981
00:36:18,035 --> 00:36:20,210
this whole separate filtering and prediction policy,

982
00:36:20,210 --> 00:36:22,910
so it can do lossless encoding, just like PNG.

983
00:36:22,910 --> 00:36:26,390
It's even got some LZ77 and dictionary encoding in there,

984
00:36:26,390 --> 00:36:27,250
so it can do that.

985
00:36:27,250 --> 00:36:29,770
The result is pretty simple.

986
00:36:29,770 --> 00:36:32,790
Across the board, all of these optimizations and techniques

987
00:36:32,790 --> 00:36:37,962
make it competitive with both PNG and JPEG everywhere.

988
00:36:37,962 --> 00:36:39,920
And it supports all of these features, as well.

989
00:36:39,920 --> 00:36:42,208
And in most time, it's actually winning, if you check out those.

990
00:36:42,208 --> 00:36:44,020
So you get smaller file sizes.

991
00:36:44,020 --> 00:36:46,250
You get more features in those file sizes.

992
00:36:46,250 --> 00:36:48,640
And it's supported natively on Android, which is awesome.

993
00:36:48,640 --> 00:36:50,056
Round of applause for that, right?

994
00:36:50,056 --> 00:36:55,320
[APPLAUSE]

995
00:36:55,320 --> 00:36:55,980
OK.

996
00:36:55,980 --> 00:36:57,577
Now, let's get real for a minute.

997
00:36:57,577 --> 00:36:59,910
I know we laughed at gummy bears and had a clapping war,

998
00:36:59,910 --> 00:37:00,440
but let's get real.

999
00:37:00,440 --> 00:37:01,200
Can we get real?

1000
00:37:01,200 --> 00:37:02,210
Round of applause for getting real.

1001
00:37:02,210 --> 00:37:02,810
[APPLAUSE]

1002
00:37:02,810 --> 00:37:03,309
Yeah?

1003
00:37:05,920 --> 00:37:07,940
The weirdest applause request ever.

1004
00:37:07,940 --> 00:37:11,050
If there's one thing you remember-- some bald guy got

1005
00:37:11,050 --> 00:37:12,680
on stage at Google I/O. I was hiding

1006
00:37:12,680 --> 00:37:13,880
in a tent trying to get out of the sun,

1007
00:37:13,880 --> 00:37:16,379
and he yelled at me for an hour, but I remembered one thing.

1008
00:37:16,379 --> 00:37:17,280
It's this.

1009
00:37:17,280 --> 00:37:18,330
This is one thing.

1010
00:37:18,330 --> 00:37:19,520
This is all I'm asking you to remember.

1011
00:37:19,520 --> 00:37:20,019
That's it.

1012
00:37:20,019 --> 00:37:21,650
Nothing else, just this, OK?

1013
00:37:21,650 --> 00:37:22,830
This diagram.

1014
00:37:22,830 --> 00:37:26,130
When you're choosing what kind of image to make,

1015
00:37:26,130 --> 00:37:28,114
the decision on the format is super important.

1016
00:37:28,114 --> 00:37:29,780
The first thing you have to ask yourself

1017
00:37:29,780 --> 00:37:32,380
is, can this image be a vector drawable?

1018
00:37:32,380 --> 00:37:33,861
If yes, make it a vector drawable.

1019
00:37:33,861 --> 00:37:34,360
Done.

1020
00:37:34,360 --> 00:37:34,859
Easy.

1021
00:37:34,859 --> 00:37:35,840
Go to lunch.

1022
00:37:35,840 --> 00:37:40,250
If no, ask yourself, do I support WebP?

1023
00:37:40,250 --> 00:37:41,510
If yes, make it a WebP.

1024
00:37:41,510 --> 00:37:42,120
Go to lunch.

1025
00:37:42,120 --> 00:37:43,130
You're done for the day.

1026
00:37:43,130 --> 00:37:43,670
Good job.

1027
00:37:43,670 --> 00:37:44,340
Peer bonus.

1028
00:37:44,340 --> 00:37:46,120
Sweet.

1029
00:37:46,120 --> 00:37:49,760
If you don't support WebP, ask yourself, does it need transparency?

1030
00:37:49,760 --> 00:37:52,334
If yes, obviously, you've got to use PNG for that.

1031
00:37:52,334 --> 00:37:54,750
If no, you've got to ask yourself, is it simple or complex?

1032
00:37:54,750 --> 00:37:57,230
Remember, PNG optimizes and compresses better

1033
00:37:57,230 --> 00:37:59,740
in areas of very self-similar pixels.

1034
00:37:59,740 --> 00:38:02,000
So the more photo-realistic an image, the worse

1035
00:38:02,000 --> 00:38:03,560
PNG is going to compress it.

1036
00:38:03,560 --> 00:38:05,440
The more simpler an image, the better PNG's

1037
00:38:05,440 --> 00:38:06,690
going to compress it, right?

1038
00:38:06,690 --> 00:38:08,726
If it's complex, we're going to go JPEG.

1039
00:38:08,726 --> 00:38:11,770
Now, if we end up at PNG, we want

1040
00:38:11,770 --> 00:38:14,630
to make sure that we're running a tool on it, reducing

1041
00:38:14,630 --> 00:38:16,079
colors, trying to make it indexed,

1042
00:38:16,079 --> 00:38:19,260
and hand-optimizing it in places where we need to for Hero assets.

1043
00:38:19,260 --> 00:38:20,230
Same thing with JPEG.

1044
00:38:20,230 --> 00:38:25,965
Use a tool, correct the quality, and hand optimize where you can.

1045
00:38:25,965 --> 00:38:27,590
I love that everyone's taking pictures.

1046
00:38:27,590 --> 00:38:29,120
This is live streamed.

1047
00:38:29,120 --> 00:38:30,630
You can get this later.

1048
00:38:30,630 --> 00:38:32,069
[LAUGHTER]

1049
00:38:32,069 --> 00:38:34,110
In fact, if you check out the Spaces application,

1050
00:38:34,110 --> 00:38:35,079
I'll put this up later.

1051
00:38:35,079 --> 00:38:36,495
Put your phones down, you're good.

1052
00:38:36,495 --> 00:38:37,449
[LAUGHTER]

1053
00:38:37,449 --> 00:38:39,490
I'm flattered that you're taking a picture of me,

1054
00:38:39,490 --> 00:38:40,550
but you know-- I can pose.

1055
00:38:40,550 --> 00:38:41,950
Anyone want a picture of the pose?

1056
00:38:41,950 --> 00:38:42,330
[LAUGHTER]

1057
00:38:42,330 --> 00:38:42,420
No?

1058
00:38:42,420 --> 00:38:42,920
Anybody?

1059
00:38:42,920 --> 00:38:43,676
Oh, Someone there.

1060
00:38:43,676 --> 00:38:45,494
[LAUGHTER]

1061
00:38:45,494 --> 00:38:46,160
AUDIENCE: There.

1062
00:38:46,160 --> 00:38:46,917
There.

1063
00:38:46,917 --> 00:38:48,542
COLT MCANLIS: Oh, need to be over here?

1064
00:38:48,542 --> 00:38:50,310
[LAUGHTER]

1065
00:38:50,310 --> 00:38:50,810
OK, no.

1066
00:38:50,810 --> 00:38:51,150
We've got to get back.

1067
00:38:51,150 --> 00:38:51,990
We've got to get back to it.

1068
00:38:51,990 --> 00:38:53,531
The A/V people are getting mad at me.

1069
00:38:53,531 --> 00:38:54,040
Sorry.

1070
00:38:54,040 --> 00:38:54,540
OK.

1071
00:38:54,540 --> 00:38:58,620
Most importantly, though, this one simple thing, profile your code.

1072
00:38:58,620 --> 00:39:00,160
Profile your code.

1073
00:39:00,160 --> 00:39:01,347
Profile your code.

1074
00:39:01,347 --> 00:39:03,930
Before you make any decisions, before you make any performance

1075
00:39:03,930 --> 00:39:05,555
changes, before you change your format,

1076
00:39:05,555 --> 00:39:09,430
before you put bits on the wire that your users are

1077
00:39:09,430 --> 00:39:13,960
going to have to pay to download, profile it.

1078
00:39:13,960 --> 00:39:16,890
Make a decision based upon evidence, and data,

1079
00:39:16,890 --> 00:39:18,770
and the best thing for your users.

1080
00:39:18,770 --> 00:39:21,160
Do not go lazily into these decisions,

1081
00:39:21,160 --> 00:39:23,050
because they have huge ramifications

1082
00:39:23,050 --> 00:39:25,770
for the people who love you and your applications.

1083
00:39:25,770 --> 00:39:27,010
Profile it.

1084
00:39:27,010 --> 00:39:30,410
In some cases, JPEG's going to be better than PNG.

1085
00:39:30,410 --> 00:39:32,910
In some cases, WebP's going to be the best option.

1086
00:39:32,910 --> 00:39:34,746
In some cases, it's going to load too slow,

1087
00:39:34,746 --> 00:39:36,370
and you're going to want to use a JPEG.

1088
00:39:36,370 --> 00:39:39,850
In every single situation, profile your code.

1089
00:39:39,850 --> 00:39:41,290
Find the sweet spot.

1090
00:39:41,290 --> 00:39:44,840
Optimize for your users, in every case.

1091
00:39:44,840 --> 00:39:47,450
And thank you, thank you, thank you, so much,

1092
00:39:47,450 --> 00:39:48,630
for coming to this session.

1093
00:39:48,630 --> 00:39:49,588
My name's Colt McAnlis.

1094
00:39:49,588 --> 00:39:50,540
[APPLAUSE]

1095
00:39:50,540 --> 00:39:54,790
[MUSIC PLAYING]

